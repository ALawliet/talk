#!/usr/bin/env node

/**
 * Module dependencies.
 */

const program = require('./commander');

const mongoose = require('../services/mongoose');
const util = require('./util');
const fs = require('fs');

const UserModel = require('../models/user');
const CommentModel = require('../models/comment');

const AssetService = require('../services/assets');
const CommentService = require('../services/comments');

// Register the shutdown criteria.
util.onshutdown([
  () => mongoose.disconnect()
]);

// Reads strategy file, validates it and returns an object.
function normalizeStrategy(strategy_file) {
  return new Promise((resolve, reject) => {
    fs.readFile(strategy_file, function(err, data) {
      if (err) {
        reject(err);
      }
      resolve(JSON.parse(data));
    });
  });
}

function get_value(old_comment, field) {
  let value = old_comment;
  if (field['source'].includes('.')) {
    let i = field['source'].split('.');
    for (const f of i) {
      value = value[f];
    }
  } else {
    value = old_comment[field['source']];
  }
  return value;
}

// TO DO: replace with UserService.findOrCreateExternalUser({id, provider, displayName}) when we have a clear idea of the provider for authentication
function get_user(old_user, map) {
  let user = {};

  let fields = map.fields;
  let status = map.status;

  for (let field in fields) {
    switch(field) {
    case 'metadata':
      user[field] = {};
      for (let f of fields[field]) {
        user[field][f] = old_user[f];
      }
      break;
    case 'status':
      user[field] = status[old_user['status']];
      break;
    case 'provider':
      user['profiles'] = [{
        'id': old_user[fields[field]],
        'provider': 'wapo'
      }];
      break;
    default:
      user[field] = old_user[fields[field]];
      break;
    }
  }
  user['lowercaseUsername'] = user['username'].toLowerCase();

  return user;
}

function get_metadata(old_comment, field) {
  let metadata = {};
  for (let f of field['fields']) {
    metadata[f['name']] = get_value(old_comment, f);
  }
  return metadata;
}

function transform_field(old_comment, field) {
  switch(field['relation']) {
  case 'Identity':
    return new Promise((resolve) => {
      return resolve(get_value(old_comment, field));
    });

  case 'FindOrCreateUser':

    // It needs to find a the user by the username.
    // Otherwise it will create it with the data that has available.
    return UserModel
      .findOneAndUpdate(
      {
        username: get_value(old_comment, field)
      },
      get_user(old_comment[field['object']], field['map']),
      {
        new: true,
        upsert: true,
        setDefaultsOnInsert: true
      }
      ).then((user) => {
        return user.id;
      })
      .catch((err) => {
        console.error(err);
        return null;
      });

  case 'FindOrCreateAsset':
    return AssetService
      .findOrCreateByUrl(get_value(old_comment, field))
      .then((asset) => {
        return asset.id;
      })
      .catch((err) => {
        console.error(err);
        return null;
      });

  case 'Status':
    return new Promise((resolve) => {
      return resolve(field['status'][get_value(old_comment, field)]);
    });

  case 'Array':
    return new Promise((resolve) => {
      return resolve(get_value(old_comment, field)
          .map(function(t){
            return {
              'name': t,
              'created_at': new Date(),
              'assigned_by': null
            };
          }));
    });

  case 'Parent':

    // Look for the Comment that is the parent of this comment.
    return CommentModel.findOne({'metadata.id': get_value(old_comment, field)})
      .then((comment) => {
        return comment && comment.id;
      })
      .catch((err) => {
        console.error('error ', err);
        return null;
      });

  case 'Metadata':
    return new Promise((resolve) => {
      return resolve(get_metadata(old_comment, field));
    });
  }
}

function transform(old_comment, strategy) {
  let fields = strategy.fields;
  let comment = {};
  let promises = [];

  for (let field in fields) {
    promises.push(
      transform_field(old_comment, fields[field])
      .then((value) => {
        comment[field] = value;
      })
    );
  }

  return Promise.all(promises)
      .then(() => {
        return CommentService.publicCreate(comment);
      });
}

/**
* Import comments into the database.
*/
function importComments(file) {

  // Get strategy to use.
  normalizeStrategy(file)
  .then((strategy) => new Promise((resolve, reject) => {

    console.info('Importing comments for strategy %s.', strategy.name);

    // Mongo data to import.
    let url = strategy.database;

    // Connect to the Mongo instance.
    let db = mongoose.createConnection(url, {socketOptions: {keepAlive: 120}});

    db.once('open', function(){
      let comments = db.collection('comments');
      let stream = comments.find().stream();

      stream.on('data', function(doc) {

        // work with the document to transform and import it
        transform(doc, strategy.map.entities.comments)
        .then((comment) => {
          console.info('Imported %s.', comment.id);
        })
        .catch((err) => {
          console.error(err);
        });
      });

      stream.on('error', (err) => {
        return reject(err);
      });

      stream.on('end', () => {
        return resolve();
      });
    });
  }))
  .then(() => {
    util.shutdown();
  })
  .catch((err) => {
    console.error(err);
    util.shutdown(1);
  });
}

//==============================================================================
// Setting up the program command line arguments.
//==============================================================================

program
  .command('import <file>')
  .description('import comments into database via strategy file')
  .action(importComments);

program.parse(process.argv);

// If there is no command listed, output help.
if (!process.argv.slice(2).length) {
  program.outputHelp();
  util.shutdown();
}
